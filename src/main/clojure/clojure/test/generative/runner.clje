;   Copyright (c) Rich Hickey, Stuart Halloway, and contributors.
;   All rights reserved.
;   The use and distribution terms for this software are covered by the
;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;   which can be found in the file epl-v10.html at the root of this distribution.
;   By using this software in any fashion, you are agreeing to be bound by
;   the terms of this license.
;   You must not remove this notice, or any other, from this software.

(ns clojure.test.generative.runner
  (:require
   [clojure.data.generators :as gen]
   [clojure.test.generative :as tgen]
   [clojure.string :as str]))

(set! *warn-on-infer* true)

(def ^:private config-mapping
     [["clojure.test.generative.threads"
       [:nthreads]
       read-string
       (max 1 (dec (erlang/system_info :schedulers)))]
      ["clojure.test.generative.msec"
       [:msec]
       read-string
       10000]])

(defn config
  "Returns runner configuration derived from system properties."
  []
  (reduce
   (fn [m [prop path coerce default]]
     (let [val (-> prop
                   erlang/binary_to_list
                   (os/getenv #erl"")
                   erlang/list_to_binary)]
       (if (seq val)
         (assoc-in m path (coerce val))
         (assoc-in m path default))))
   {}
   config-mapping))

(defprotocol Testable
  (get-tests [_]))

(extend-protocol Testable
  clojerl.Var
  (get-tests
   [^clojerl.Var v]
   (let [m (meta v)
         arg-fns (::tgen/arg-fns m)
         specs (::tgen/specs m)]
     (cond
      arg-fns
      [{:test (-> (if-let [^clojerl.Namespace ns (find-ns (.namespace v))]
                    (str (.name ns) "/" (.name v))
                    (.name v))
                  symbol)
        :input-gen (fn []
                     (repeatedly
                      (fn []
                        (into [] (map #(%) arg-fns)))))}]

      specs
      @v))))

(defn- path->symbol [root path]
  (let [path (if root
               (subs path (count root))
               path)
        ns-name (-> path
                    filename/rootname
                    (str/replace #"/" ".")
                    (str/replace #"_" "-"))
        ns-symbol (symbol ns-name)]
    ns-symbol))

(defn clojure-source-file?
  "DEPRECATED; moved to clojure.tools.namespace.file

  Returns true if file is a normal file with a .clj or .cljc extension."
  {:deprecated "0.2.1"
   :added "0.1.0"}
  [file]
  (and (filelib/is_regular file)
       (#{".clje" ".cljc"} (filename/extension file))))

(defn find-clojure-sources-in-dir
  "DEPRECATED; moved to clojure.tools.namespace.find

  Searches recursively under dir for Clojure source files (.clje, .cljc).
  Returns a sequence of paths, in breadth-first sort order."
  {:deprecated "0.2.1"
   :added "0.1.0"}
  [dir]
  ;; Use sort by absolute path to get breadth-first search.
  (sort-by #(filename/absname %)
           (filter clojure-source-file? (file-seq dir))))

(defn comment?
  "DEPRECATED; moved to clojure.tools.namespace.parse

  Returns true if form is a (comment ...)"
  {:deprecated "0.2.1"
   :added "0.1.0"}
  [form]
  (and (list? form) (= 'comment (first form))))

(defn ns-decl?
  "DEPRECATED; moved to clojure.tools.namespace.parse

  Returns true if form is a (ns ...) declaration."
  {:deprecated "0.2.1"
   :added "0.1.0"}
  [form]
  (and (list? form) (= 'ns (first form))))

(defn read-ns-decl
  "DEPRECATED; moved to clojure.tools.namespace.parse

  Attempts to read a (ns ...) declaration from rdr, and returns the
  unevaluated form.  Returns nil if read fails or if a ns declaration
  cannot be found.  The ns declaration must be the first Clojure form
  in the file, except for (comment ...)  forms."
  {:deprecated "0.2.1"
   :added "0.1.0"}
  [^erlang.io.PushbackReader rdr]
  (try
   (loop [] (let [form (doto (read rdr) str)]
              (cond
                (ns-decl? form) form
                (comment? form) (recur)
                :else nil)))
   (catch clojerl.Error e nil)))

(defn read-file-ns-decl
  "DEPRECATED; moved to clojure.tools.namespace.file

  Attempts to read a (ns ...) declaration from file, and returns the
  unevaluated form.  Returns nil if read fails, or if the first form
  is not a ns declaration."
  {:deprecated "0.2.1"
   :added "0.1.0"}
  [file]
  (with-open [rdr (erlang.io.PushbackReader. (erlang.io.File. file))]
    (read-ns-decl rdr)))

(defn find-ns-decls-in-dir
  "DEPRECATED; moved to clojure.tools.namespace.find

  Searches dir recursively for (ns ...) declarations in Clojure
  source files; returns the unevaluated ns declarations."
  {:deprecated "0.2.1"
   :added "0.1.0"}
  [dir]
  (filter identity (map read-file-ns-decl (find-clojure-sources-in-dir dir))))

(defn find-namespaces-in-dir
  "DEPRECATED; moved to clojure.tools.namespace.find

  Searches dir recursively for (ns ...) declarations in Clojure
  source files; returns the symbol names of the declared namespaces."
  [dir]
  (map second (find-ns-decls-in-dir dir)))

(defn- find-vars-in-namespaces
  [& nses]
  (when nses
    (reduce (fn [v ns] (into v (vals (ns-interns ns)))) [] nses)))

(defn- find-vars-in-dirs
  [& dirs]
  (let [nses (mapcat #(find-namespaces-in-dir %) dirs)]
    (doseq [ns nses] (require ns))
    (apply find-vars-in-namespaces nses)))

(defn- run-one
  "Run f (presumably for side effects) repeatedly on n threads,
   until msec has passed or somebody throws an exception.
   Returns as many status maps as seeds passed in."
  [{:keys [test input-gen]} {:keys [msec seeds]}]
  (let [f (eval test)
        start (erlang/monotonic_time :milli_seconds)]
    (mapv
     #(try
        (gen/with-seed %
          (loop [iter 0
                 [input & more] (input-gen)]
            (let [status {:iter iter :seed % :test test :input input}]
              (if input
                (let [failure (try
                                (apply f input)
                                nil
                                (catch _ t :stack stack
                                       (assoc status
                                              :exception t
                                              :stack stack)))
                      now (erlang/monotonic_time :milli_seconds)]
                  (cond
                    failure failure
                    (< now (+ start msec)) (recur (inc iter) more)
                    :else (select-keys status [:test :seed :iter])))
                (assoc status :exhausted true))))))
     seeds)))

(defn- failed?
  "Does test result indicate a failure?"
  [result]
  (contains? result :exception))

(defn next-seed []
  (rand/uniform 1000000000000))

(defn- run-n
  "Run tests in parallel on nthreads, dividing msec equally between the tests.
   Returns a list of maps of :iter, :seed"
  [{:keys [nthreads msec]} tests]
  (mapcat #(run-one %
                    {:msec (/ msec (count tests))
                     :seeds (repeatedly nthreads next-seed)})
          tests))

(def ^:private serializer #_(agent nil))

(defn print-stack-trace
  [stack]
  (io/format (clj_utils/format_stacktrace stack)))

(defn serialized
  "Returns a function that calls f for side effects, async,
   serialized by an agent"
  ([f] (serialized f serializer))
  ([f agt]
     (fn [& args]
       (send-off agt
                 (fn [_]
                   (try
                    (apply f args)
                    (catch _ t :stack stack
                      (print-stack-trace stack)))
                   nil))
       nil)))

(defn prf
  "Print and flush."
  [s]
  (binding [*out* *err*]
    (print s)
    (flush)))

(defn dir-tests
  "Returns all tests in dirs"
  [dirs]
  (let [load (fn [s] (require s) s)]
    (->> (mapcat #(find-namespaces-in-dir %) dirs)
         (map load)
         (apply find-vars-in-namespaces)
         (mapcat get-tests))))

(defn inputs
  "For interactive use.  Returns an infinite sequence of inputs for
   a test."
  [test]
  ((:input-gen test)))

(defn run
  "Designed for interactive use.  Prints results to *out* and throws
   on first failure encountered."
  [nthreads msec & test-containers]
  (doseq [result (run-n {:nthreads nthreads
                         :msec msec}
                        (mapcat get-tests test-containers))]
    (if (failed? result)
      (throw (ex-info "Generative test failed" result))
      (prn result))))

(defn run-suite
  "Designed for test suite use."
  [{:keys [nthreads msec progress]} tests]
  (let [progress (or progress #(prf "."))
        ret (reduce
             (fn [{:keys [failures iters nresults]} result]
               (when (:exception result)
                 (print-stack-trace (:stack result)))
               (if (:exception result)
                 (prn result)
                 (progress))
               {:failures (+ failures (if (:exception result) 1 0))
                :iters (+ iters (:iter result))
                :nresults (+ nresults 1)})
             {:failures 0 :iters 0 :nresults 0}
             (run-n {:nthreads nthreads
                     :msec msec}
                    tests))]
    (-> ret
        (assoc :tests (/ (:nresults ret) nthreads))
        (dissoc :nresults))))

(defn -main
  "Command line entry point. Calls System.exit!"
  [& dirs]
  (if (seq dirs)
    (try
     (let [result (run-suite (config) (dir-tests dirs))]
       (println "\n" result)
       (erlang/halt (:failures result)))
     (catch _ t
       (erlang/halt 1)))
    (do
      (println "Specify at least one directory with tests")
      (erlang/halt 1))))
